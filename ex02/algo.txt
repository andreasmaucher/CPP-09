write it on whiteboard
comparison of differences between both container functions

Input:
- positive input sequences (need to handle > 3000 ints)
- use merge-insert algo to sort the positive integer sequence -> Ford-Johnson algorithm

Jacobsthal number:
- sequence starts with 0 and 1 then each following number is found by adding the number before it to twice the number before that
- 0 1 1 3 5 11..


Eval:
- why each container is faster / slower and understanding the exact container operations (incl. memory)
- behavior for larger sets like 100, 1000, 3000
- no duplicate checking as algo works with duplicates and checking would add extra load and make it slower
- it needs to use recursion! (it works iterative but algo requires recursion!)
- the process of binary search
- is it ok that my larger elements start with highest and go down???
The temporary containers are used for the recursive sorting phase (which is the same for both), but the final insertion phase uses the original container type, creating the measurable difference.
Bottom line: The temporary containers don't eliminate the performance differences - they just make the algorithm more efficient while still allowing you to measure the container-specific performance characteristics.


Explanation of sorting recursively:
this is sequence with sorted pairs: (2,11) (0,17) (8,16) (6,15) (3,10) (1,21) (9,18) (14,19) (5,12) (4,20) (7,13)

next we combine two consecutive pairs e.g. (2,11) (0,17) belong together, same as  (8,16) (6,15). in this step we compare the second numbers (since it is sorted this will always be the higher number) of each pair that it is grouped with. This looks as follows: for  (2,11) (0,17) we compare 11 vs 17 since 17 is higher no change in order. but for (8,16) (6,15) since 15 < 16 we switch the order of the pairs to (6,15) (8,16). so the new order of the full sequence would be (2,11) (0,17)(6,15) (8,16) and so on. the pair in the end (7 13) has no pair to team up with so it will simply stay at the end of the sequence for now.
The next recursion level would then be to group 4 pairs into one "pair" and compare the higher number of the second pair of each double pair. e.g. (2,11) (0,17)(6,15) (8,16) would become (6,15) (8,16)(2,11) (0,17) because 17 > 16. the same logic applies to the full sequence. in this recursion run (5 12 ) (4 20) will not be able to grouped up with another double pair so they will simply keep their positions in the sequence same as (7 13). 
Now the next recursion level would be 8 pairs grouped together where 4 pairs make of a subgroup and always the last value of the subgroup will be compared. in this case this would be 6,15) (8,16)(2,11) (0,17) compared with (9, 18) (14, 19) (3, 10) (1, 21). since 17 < 21 the order will remain the same. 
There is nothing to be done at the level 5 of recursion: because the amount of numbers in the element doubles with each recursion call, at one point we won't be able to form a pair of elements. This is where we break from this level. 


Step-by-Step Thought Process
Phase 1: Understanding the Problem
Question: How do we approach implementing Ford-Johnson?
Answer: Break it down into these conceptual steps:
Pair Creation: Group elements into pairs
Pair Sorting: Sort pairs by their larger elements
Chain Building: Create a sorted "main chain"
Element Insertion: Insert remaining elements efficiently
Phase 2: Algorithm Design
Let me walk through an example: [3, 5, 9, 7, 4]
Step 1: Create Pairs
Step 2: Sort Pairs by Larger Elements
Step 3: Build Main Chain
Step 4: Insert Remaining Elements
Phase 3: Implementation Strategy
Container Choice
Why two containers?
std::vector: Fast random access, good for binary search
std::deque: Fast insertion at ends, different memory layout
Performance comparison: See which is more efficient
Data Structure Design
Phase 4: Algorithm Implementation
Core Functions Needed:
createPairs()
sortPairs()
buildMainChain()
insertRemaining()
Phase 5: Binary Search Implementation
Why binary search?
Efficiency: O(log n) instead of O(n) for linear search
Ford-Johnson requirement: Algorithm specifically uses binary insertion
Implementation:
Phase 6: Performance Measurement
Timing Strategy:
Why microseconds?
Precision: Need to see differences between containers
Accuracy: Small enough to measure algorithm performance
Phase 7: Error Handling
Validation Requirements:
Positive integers only: No negative numbers or zero
Valid format: All characters must be digits
Argument count: At least one argument required
Error Output:
Why This Algorithm is Special
Comparison Efficiency:
Ford-Johnson: Minimizes comparisons for small sequences
Binary insertion: O(log n) insertion complexity
Pair strategy: Reduces total number of comparisons needed
Real-World Applications:
Network routing: Efficient sorting of small datasets
Embedded systems: Memory-efficient sorting
Competitive programming: Optimized comparison-based sorting